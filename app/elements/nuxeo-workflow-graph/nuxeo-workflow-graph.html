<!--
(C) Copyright 2015 Nuxeo SA (http://nuxeo.com/) and contributors.

All rights reserved. This program and the accompanying materials
are made available under the terms of the GNU Lesser General Public License
(LGPL) version 2.1 which accompanies this distribution, and is available at
http://www.gnu.org/licenses/lgpl.html

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

Contributors:
    Gabriel Barata <gbarata@nuxeo.com>
-->

<script src="../../bower_components/jsPlumb/dist/js/jsPlumb-2.0.5.js"></script>

<!--
`nuxeo-workflow-graph`
@group Nuxeo UI
@element nuxeo-workflow-graph
-->
<dom-module id="nuxeo-workflow-graph">
  <template>
    <style>
      :host {
        display: block;
      }

      .workflow_node {
        position: relative;
        text-align: center;
        font-size: .92em;
        z-index: 100
      }

      .workflow_simple_task,
      .workflow_multiple_task {
        height: 80px;
        width: 80px;
        color: #006da6;
        padding-top: 1.2em;
        background-color: #f7f8f9;
        border-radius: 0.5em;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        -webkit-box-sizing: border-box;
      }

      .workflow_simple_task {
        border: 1px solid #3c9ae2;
      }

      .workflow_multiple_task {
        border: 3px double #3c9ae2;
      }

      .workflow_fork_node,
      .workflow_merge_node {
        width: 0;
        height: 0;
        border-bottom: 40px solid #a4c9da;
        border-left: 20px solid transparent;
        border-right: 20px solid transparent;
        line-height: 100%
      }

      .workflow_merge_node {
        border-top: 40px solid #dededd;
        border-bottom: 0;
        line-height: 0
      }

      .workflow_start_node,
      .workflow_end_node {
        width: 40px;
        height: 40px;
        background: #92c938;
        -moz-border-radius: 40px;
        -webkit-border-radius: 40px;
        border-radius: 40px;
        color: #fff;
        line-height: 40px
      }

      .workflow_end_node {
        background: #f04545
      }

      .workflow_subworkflow_task {
        border: 2px solid #3c9ae2;
        /*background: url("../icons/subworkflow_bg_node.png") no-repeat scroll right bottom white*/
      }

      .workflow_node_suspended {
        background-color: #e1f0ff;
        font-weight: bold
      }

      .workflow_connection_label {
        background-color: white;
        padding: .15em .25em;
        font: 12px sans-serif;
        color: #3780b9;
        z-index: 120;
        border: 1px dotted rgba(0, 0, 0, 0.2);
        opacity: 0.85;
        filter: alpha(opacity = 85);
        max-width: 170px;
        word-wrap: break-word
      }

      .targetDiv {
        position: relative;
        width: 880px;
        height: 720px
      }

      ._jsPlumb_endpoint {
        z-index: 110
      }

      ._jsPlumb_overlay {
        z-index: 6
      }
    </style>

    <nuxeo-resource id="graphRequest"
                    path="/workflow/[[workflow.id]]/graph"
                    response="{{graphResponse}}"
                    headers='{"Content-Type":"application/json"}'></nuxeo-resource>

    <div id="graph" class="targetDiv">
    </div>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'nuxeo-workflow-graph',
        properties: {
          workflow: {
            type: String,
            observer: '_workflowChanged'
          },

          dynamicAnchors: {
            type: Array,
            value: [0.5, 0.25, 0.75, 0, 1, 0.375, 0.625, 0.125, 0.875]
          },

          connectionColors: {
            type: Array,
            value: ['#92e1aa', '#F7BE81', '#BDBDBD', '#5882FA', '#E1F5A9',
              '#FA5858', '#FFFF00', '#FF0000', '#D8F781']
          },

          sourceEndpointOptions: {
            type: Object,
            value: {
              connector: ['Flowchart', {cornerRadius: 5}],
              paintStyle: {
                fillStyle: '#92e1aa'
              },
              isSource: true,
              isTarget: false,
              uniqueEndpoint: true,
              maxConnections: 1
            }
          },

          targetEndpointOptions: {
            type: Object,
            value: {
              paintStyle: {
                fillStyle: '#003f7d'
              },
              isSource: false,
              isTarget: true,
              reattach: true,
              // without specifying this the targetEndpoint doesn't accept multiple
              // connections
              maxConnections: -1
            }
          }
        },

        _workflowChanged: function() {
          var self = this;
          this.$.graphRequest.get().then(function() {
            jsPlumb.ready(function() {
              self._jsPlumbInitializeDefault();
              self._displayGraph();
            });
          });
        },

        _countElement: function(item, array) {
          var count = 0;
          array.forEach(function(i, v) {
            if (v === item) {
              count++;
            }
          });
          return count;
        },

        _jsPlumbInitializeDefault: function() {
          jsPlumb.importDefaults({
            DragOptions: {
              cursor: 'pointer',
              zIndex: 2000
            },
            PaintStyle: {
              strokeStyle: '#92e1aa',
              lineWidth: 3,
              outlineWidth: 2,
              outlineColor: 'white',
              joinstyle: 'round'
            },
            Endpoint: ['Dot', {
              radius: 6
            }],
            ConnectionOverlays: [['Arrow', {
              location: 0.8
            }, {
              foldback: 0.9,
              fillStyle: '#92e1aa',
              width: 14
            }]]
          });
          jsPlumb.setContainer(this.$.graph);
        },

        _getConnectionOverlayLabel: function(colour, condition) {
          return [['Arrow', {
            location: 0.8
          }, {
            foldback: 0.9,
            fillStyle: '#92e1aa',
            width: 14
          }], ['Label', {
            label: '<span title="' + condition + '">' + condition + '</span>',
            cssClass: 'workflow_connection_label',
            location: 0.6
          }]];
        },

        _displayGraph: function() {
          var self = this;
          var graph = Polymer.dom(this.$.graph);
          this.graphResponse.nodes.forEach(function(node) {
            var element = self.$[node.id] = document.createElement('div');
            element.id = node.id;
            element.classList.add('workflow_node');
            element.innerHTML = node.title;
            element.style.display = 'block';
            element.style.position = 'absolute';
            element.style.left = node.x + 'px';
            element.style.top = node.y + 'px';

            if (node.isStartNode) {
              element.classList.add('workflow_start_node');
            } else if (node.isEndNode) {
              element.classList.add('workflow_end_node');
            } else if (node.isMerge) {
              element.classList.add('workflow_merge_node');
            } else if (node.isMultiTask) {
              element.classList.add('workflow_multiple_task');
            } else if (node.hasSubWorkflow) {
              element.classList.add('workflow_subworkflow_task');
            } else {
              element.classList.add('workflow_simple_task');
            }
            if (node.state === 'suspended') {
              element.classList.add('workflow_node_suspended');
            }

            graph.appendChild(element);
          });

          Polymer.dom.flush();

          // initialize connection source points
          var nodes = [];

          // determine number of source endpoints per node
          var sourceEndpoints = {};
          this.graphResponse.transitions.forEach(function(transition) {
            sourceEndpoints[transition.nodeSourceId] = (sourceEndpoints[transition.nodeSourceId] || 0) + 1;
          });

          // use fixed dynamic anchors, only 9 items supported, after this everything
          // is displayed on the center
          this.graphResponse.transitions.forEach(function(transition) {
            var anchorIndex = self._countElement(transition.nodeSourceId, nodes);
            if (anchorIndex > 9) {
              anchorIndex = 0;
            }
            nodes.push(transition.nodeSourceId);
            // determine anchors for transition node
            var anchors = self.dynamicAnchors.slice(0, sourceEndpoints[transition.nodeSourceId]).sort();
            // increase index
            var endPointSource = jsPlumb.addEndpoint(transition.nodeSourceId, {
              anchor: [anchors[anchorIndex], 1, 0, 1]
            }, self.sourceEndpointOptions);
            var endPointTarget = jsPlumb.addEndpoint(transition.nodeTargetId, {
              anchor: 'TopCenter'
            }, self.targetEndpointOptions);
            // prepare the transition's path
            // ignore paths with only one segment
            var segments = [];
            if (transition.path && transition.path.length > 2) {
              for (var i = 1; i < transition.path.length; i++) {
                segments.push({
                  start: [transition.path[i - 1].x, transition.path[i - 1].y],
                  end: [transition.path[i].x, transition.path[i].y]
                });
              }
            }
            jsPlumb.connect({
              source: endPointSource,
              target: endPointTarget,
              overlays: self._getConnectionOverlayLabel(self.connectionColors[anchorIndex],
                  transition.label),
              paintStyle: {
                lineWidth: 3,
                strokeStyle: self.connectionColors[anchorIndex],
                outlineWidth: 2,
                outlineColor: 'white',
                joinstyle: 'round'
              },
              detachable: false,
              path: segments
            });
          });
          var input = document.createElement('input');
          graph.appendChild(input);
          input.setAttribute('type', 'hidden');
          input.setAttribute('name', 'graphInitDone');
          input.setAttribute('value', 'true');
        }
      });
    })();
  </script>

</dom-module>
