<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="nuxeo-data-table">
  <template>
    <style is="custom-style">
      :host {
        display: block;
        position: relative;
        -webkit-overflow-scrolling: touch;

        /* Default height just to help users get started in making stuff visible.  */
        height: 100vh;

        @apply(--nuxeo-data-table);
      }

      #container {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
      }

      #header {
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.1);
        transition: box-shadow 200ms;
        -webkit-transition: box-shadow 200ms;
        z-index: 1;
        @apply(--nuxeo-data-table-header);
      }

      #header.scrolled {
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06), 0 2px 0 rgba(0, 0, 0, 0.075), 0 3px 0 rgba(0, 0, 0, 0.05), 0 4px 0 rgba(0, 0, 0, 0.015);
      }

      #list {
        transition: opacity 200ms;
        -webkit-transition: opacity 200ms;
      }

      :host[loading] #list {
        opacity: 0.25;
      }

      :host[loading] paper-spinner-lite {
        position: absolute;
        top: 45%;
        left: 50%;
        --paper-spinner-color: var(--default-primary-color);
      }
    </style>

    <nuxeo-page-provider id="provider" auto
       provider="[[provider]]"
       page-size="[[pageSize]]"
       number-of-pages="{{pageCount}}"
       aggregations="{{aggregations}}"
       enrichers="[[enrichers]]"
       page="[[pageNumber]]"
       current-page="{{currentPage}}"
       is-next-page-available="{{isNextPageAvailable}}"
       current-page-size="{{currentPageSize}}"
       params="[[_computedParams]]"
       sort="[[_ppSort]]"
       on-update="_updateResults">
    </nuxeo-page-provider>

    <div id="container">
      <div id="header">
        <data-table-row header>
          <template is="dom-repeat" items="[[columns]]" as="column">
            <data-table-cell header column="[[column]]" bind="[[_bind(column)]]">
              <data-table-column-sort sort-order="[[sortOrder]]" path="[[column.sortBy]]" on-sort-direction-changed="_sortDirectionChanged" hidden$="[[!column.sortBy]]"></data-table-column-sort>
            </data-table-cell>
          </template>
          <nuxeo-data-table-mode header value="{{selectedMode}}"></nuxeo-data-table-mode>
        </data-table-row>
      </div>

      <iron-scroll-threshold id="scrollThreshold"
        lower-threshold="1000"
        on-lower-threshold="_loadMoreData">
        <iron-list id="list" as="item" items="[[items]]"
          scroll-target="scrollThreshold">
          <template>
            <div class="item">
              <data-table-row tabindex$="[[tabIndex]]"
                              bind="[[_bind(item, index)]]"
                              before-bind="[[beforeRowBind]]"
                              even$="[[!_isEven(index)]]">
                <template is="dom-repeat" items="[[columns]]" as="column" index-as="colIndex">
                  <data-table-cell column="[[column]]" bind="[[_bind(item, index)]]"
                    before-bind="[[beforeCellBind]]">
                  </data-table-cell>
                </template>
                <data-table-checkbox></data-table-checkbox>
              </data-table-row>
            </div>
          </template>
        </iron-list>
      </iron-scroll-threshold>
    </div>
    <paper-spinner-lite active hidden=[[!loading]]></paper-spinner-lite>
    <content select="data-table-column"></content>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-data-table',

      behaviors: [
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'column-filter-changed': '_onColumnFilterChanged',
        'iron-resize': '_resizeCellContainers',
        'scroll': '_onHorizontalScroll'
      },

      properties: {

        /**
         * A function that is called before data is bound to a row cell.
         * Can be used to customize the cell element depending on the data.
         * #### Example:
         * ```js
         * function(data, cell) {
         *   cell.toggleClass('custom', data.useCustomClass);
         * }
         * ```
         */
        beforeCellBind: {
          type: Object,
          value: function() {
            return function(/*data, cell*/) {
            };
          }
        },

        /**
         * A function that is called before data is bound to a row.
         * Can be used to customize the row element depending on the data.
         * #### Example:
         * ```js
         * function(data, row) {
         *   row.toggleClass('custom', data.useCustomClass);
         * }
         * ```
         */
        beforeRowBind: Object,

        /**
         * An array containing the items which will be stamped to the column template
         * instances.
         */
        items: {
          type: Array
        },

        /**
         * An array containing path/filter value pairs that are used to filter the items
         */
        filter: {
          type: Array,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * An array with a path/sortorder ('asc' or 'desc') pairs that are used to sort the items.
         */
        sortOrder: {
          type: Array,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * An array of `data-table-column` elements which contain the templates
         * to be stamped with items.
         */
        columns: {
          type: Array,
          notify: true,
          observer: '_columnsChanged'
        },

        _pagesLoading: {
          type: Number,
          observer: '_pagesLoadingChanged',
          value: 0
        },

        /**
         * `true` if the table is currently loading data from the data source.
         */
        loading: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
          value: false
        },

        /* nuxeo attributes */
        params: {
          type: Object,
          value: {},
          notify: true
        },
        _ppSort: {
          type: Object,
          value: {},
          notify: true
        },
        _ppFilters: {
          type: Object,
          value: {}
        },
        _computedParams: {
          type: Object,
          computed: '_computeParams(params, _ppFilters)'
        },
        provider: {
          type: String
        },
        aggregations: {
          type: Object,
          value: {},
          notify: true
        },
        pageNumber: {
          type: Number,
          value: 1
        },
        pageSize: {
          type: Number,
          value: 40
        },
        pageCount: {
          type: Number,
          value: 1
        },
        isNextPageAvailable: {
          type: Boolean,
          value: false
        },

        selectedMode: {
          type: String,
          value: 'table'
        }
      },

      observers: [
        '_resetResults(provider, params.*, _ppSort.*)'
      ],

      _computeParams: function(params, _ppFilters) {
        var result = {};
        jQuery().extend(result, params, _ppFilters);
        return result;
      },

      _loadMoreData: function(e) {
        if ((e.currentTarget.id === 'scrollThreshold' ? !this.manualLoading : this.manualLoading) &&
            this.provider &&
            this.isNextPageAvailable) {
          console.log('_loadMoreData');
          this._pagesLoading++;
          this.pageNumber = this.pageNumber + 1;
        }
      },

      _updateResults: function() {
        if (this.$.provider.page === 1) {
          this.items = [];
        }
        var docs = this.$.provider.currentPage;
        docs.forEach(function(doc) {
          this.push('items', doc);
        }.bind(this));
        this.$.list.notifyResize();
        this.$.scrollThreshold.clearTriggers();

        console.log('_updateResults');
        this._pagesLoading--;
      },

      _resetResults: function() {
        console.log('_resetResults');
        this._pagesLoading++;
        this.pageNumber = 1;
        this.docItems = [];
        this.isNextPageAvailable = false;
        this._ppFilters = {};
      },

      created: function() {
        this._observer = Polymer.dom(this).observeNodes(function(info) {
          var hasColumns = function(node) {
            return (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'DATA-TABLE-COLUMN');
          };

          if (info.addedNodes.filter(hasColumns).length > 0 ||
            info.removedNodes.filter(hasColumns).length > 0) {
            this.set('columns', this.getContentChildren('[select=data-table-column]'));
            this.notifyResize();
          }

        }.bind(this));
      },

      ready: function() {
        this.$.list._selectionHandler = function(e) {
          var first = Polymer.dom(e).event.path.filter(function(p) {
            return this.modelForElement(p);
          }.bind(this))[0];

          var model = this.modelForElement(first);
          if (model) {
            this.toggleSelectionForItem(model[this.as]);
          }
        };
      },

      _bind: function(item, index) {
        if (index !== undefined) {
          return {
            item: item,
            index: index
          };
        } else {
          return {
            column: item
          };
        }
      },

      _isEven: function(index) {
        return index % 2 === 0;
      },

      _sortDirectionChanged: function(e) {
        var notFound = true;
        for (var i = 0; i < this.sortOrder.length; i++) {
          if (this.sortOrder[i].path === e.detail.path) {
            if (e.detail.direction) {
              this.set('sortOrder.' + i + '.direction', e.detail.direction);
            } else {
              this.splice('sortOrder', i, 1);
            }
            notFound = false;
            break;
          }
        }
        if (notFound) {
          this.push('sortOrder', {
            path: e.detail.path,
            direction: e.detail.direction
          });
        }

        // TODO make it simpler
        var tmpSort = {};
        if (this.sortOrder && this.sortOrder.length > 0) {
          this.sortOrder.forEach(function(sortItem) {
            tmpSort[sortItem.path] = sortItem.direction;
          });
        }
        if (JSON.stringify(this._ppSort) !== JSON.stringify(tmpSort)) {
          this._ppSort = tmpSort;
        }
      },

      _columnsChanged: function(columns, oldColumns) {
        if (oldColumns) {
          oldColumns.forEach(function(column) {
            this.unlisten(column, 'filter-value-changed');
          }.bind(this));
        }

        if (columns) {
          columns.forEach(function(column) {
            this.listen(column, 'filter-value-changed', '_onColumnFilterChanged');
          }.bind(this));
        }
      },

      _onColumnFilterChanged: function(e) {
        var notFound = true;
        for (var i = 0; i < this.filter.length; i++) {
          if (this.filter[i].path === e.detail.filterBy) {
            this.set('filter.' + i + '.filter', e.detail.value);
            notFound = false;
            break;
          }
        }

        if (notFound) {
          this.push('filter', {
            path: e.detail.filterBy,
            filter: e.detail.value
          });
        }

        var tmpFilters = {};
        if (this.filter && this.filter.length > 0) {
          this.filter.forEach(function(filterItem) {
            if (filterItem.filter.length > 0) {
              if (filterItem.path === 'title') {
                tmpFilters[filterItem.path] = filterItem.filter + '*';
              } else {
                tmpFilters[filterItem.path] = filterItem.filter;
              }
            }
          });
        }
        if (JSON.stringify(this._ppFilters) !== JSON.stringify(tmpFilters)) {
          this._ppFilters = tmpFilters;
        }

      },

      _resizeCellContainers: function() {
        // reset header width first to make the cells and scroll width to reset their widths.
        this.$.container.style.width = '';

        this.async(function() {
          this.$.container.style.width = Math.min(this.scrollWidth, this.clientWidth + this.scrollLeft) + 'px';
        }.bind(this));
      },

      _onHorizontalScroll: function() {
        if (!this.isDebouncerActive('scrolling')) {
          this.$.container.style.width = this.scrollWidth + 'px';
          this.debounce('scrolling', function() {
            this.$.container.style.width = Math.min(this.scrollWidth, this.clientWidth + this.scrollLeft) + 'px';
            // long timeout here to prevent jerkiness with the rubberband effect on iOS especially.
          }, 1000);
        }
      },

      _pagesLoadingChanged: function(pagesLoading) {
        console.log('pagesLoading ' + pagesLoading);
        this.loading = pagesLoading > 0;
      }

    });
  </script>
</dom-module>
